// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protobuf/proto.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// requests
enum ApiProto_VpnReqMsgType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case startVpn // = 0
  case stopVpn // = 1
  case updateStats // = 2
  case echoReq // = 3
  case getEvents // = 4

  init() {
    self = .startVpn
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .startVpn
    case 1: self = .stopVpn
    case 2: self = .updateStats
    case 3: self = .echoReq
    case 4: self = .getEvents
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .startVpn: return 0
    case .stopVpn: return 1
    case .updateStats: return 2
    case .echoReq: return 3
    case .getEvents: return 4
    }
  }

}

#if swift(>=4.2)

extension ApiProto_VpnReqMsgType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// events
enum ApiProto_IMainClientState: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Before 'Connecting' ...
  case capkeyNeeded // = 0
  case credentialsNeeded // = 1
  case credentialsPasswordNeeded // = 2
  case wrongCredentialsPassword // = 3
  case waitingForNetwork // = 4

  /// 'Connecting' and after ...
  case connecting // = 5
  case connected // = 6
  case failed // = 7
  case closing // = 8
  case closed // = 9

  init() {
    self = .capkeyNeeded
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .capkeyNeeded
    case 1: self = .credentialsNeeded
    case 2: self = .credentialsPasswordNeeded
    case 3: self = .wrongCredentialsPassword
    case 4: self = .waitingForNetwork
    case 5: self = .connecting
    case 6: self = .connected
    case 7: self = .failed
    case 8: self = .closing
    case 9: self = .closed
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .capkeyNeeded: return 0
    case .credentialsNeeded: return 1
    case .credentialsPasswordNeeded: return 2
    case .wrongCredentialsPassword: return 3
    case .waitingForNetwork: return 4
    case .connecting: return 5
    case .connected: return 6
    case .failed: return 7
    case .closing: return 8
    case .closed: return 9
    }
  }

}

#if swift(>=4.2)

extension ApiProto_IMainClientState: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum ApiProto_EventID: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case eventStateChange // = 131073
  case eventSocketOpened // = 65537
  case eventSocketClosed // = 65538
  case eventVpnSetup // = 196609
  case eventVpnProtect // = 196614
  case eventVpnConnecting // = 196610
  case eventVpnConnected // = 196611
  case eventVpnDisconnected // = 196612
  case eventVpnFailed // = 196613
  case eventAdditionError // = 327680
  case eventSysAdditional // = 393216
  case eventInfo // = 458752
  case unknown // = -1

  init() {
    self = .eventStateChange
  }

  init?(rawValue: Int) {
    switch rawValue {
    case -1: self = .unknown
    case 65537: self = .eventSocketOpened
    case 65538: self = .eventSocketClosed
    case 131073: self = .eventStateChange
    case 196609: self = .eventVpnSetup
    case 196610: self = .eventVpnConnecting
    case 196611: self = .eventVpnConnected
    case 196612: self = .eventVpnDisconnected
    case 196613: self = .eventVpnFailed
    case 196614: self = .eventVpnProtect
    case 327680: self = .eventAdditionError
    case 393216: self = .eventSysAdditional
    case 458752: self = .eventInfo
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return -1
    case .eventSocketOpened: return 65537
    case .eventSocketClosed: return 65538
    case .eventStateChange: return 131073
    case .eventVpnSetup: return 196609
    case .eventVpnConnecting: return 196610
    case .eventVpnConnected: return 196611
    case .eventVpnDisconnected: return 196612
    case .eventVpnFailed: return 196613
    case .eventVpnProtect: return 196614
    case .eventAdditionError: return 327680
    case .eventSysAdditional: return 393216
    case .eventInfo: return 458752
    }
  }

}

#if swift(>=4.2)

extension ApiProto_EventID: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum ApiProto_VpnErrType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case alreadyActive // = 1
  case credFileNotFound // = 2
  case credFileFileBad // = 3
  case capFileNotFound // = 4
  case passBad // = 5
  case noRight // = 6
  case helperConnectionLost // = 7
  case serviceConLost // = 8
  case emailisNotVerified // = 9
  case intenalError1 // = 500
  case intenalError2 // = 501
  case intenalError3 // = 502
  case intenalError4 // = 503
  case intenalError5 // = 504

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .alreadyActive
    case 2: self = .credFileNotFound
    case 3: self = .credFileFileBad
    case 4: self = .capFileNotFound
    case 5: self = .passBad
    case 6: self = .noRight
    case 7: self = .helperConnectionLost
    case 8: self = .serviceConLost
    case 9: self = .emailisNotVerified
    case 500: self = .intenalError1
    case 501: self = .intenalError2
    case 502: self = .intenalError3
    case 503: self = .intenalError4
    case 504: self = .intenalError5
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .alreadyActive: return 1
    case .credFileNotFound: return 2
    case .credFileFileBad: return 3
    case .capFileNotFound: return 4
    case .passBad: return 5
    case .noRight: return 6
    case .helperConnectionLost: return 7
    case .serviceConLost: return 8
    case .emailisNotVerified: return 9
    case .intenalError1: return 500
    case .intenalError2: return 501
    case .intenalError3: return 502
    case .intenalError4: return 503
    case .intenalError5: return 504
    }
  }

}

#if swift(>=4.2)

extension ApiProto_VpnErrType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum ApiProto_SysAdditionalEventsType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case serviceReady // = 0

  init() {
    self = .serviceReady
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .serviceReady
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .serviceReady: return 0
    }
  }

}

#if swift(>=4.2)

extension ApiProto_SysAdditionalEventsType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// response
enum ApiProto_VpnRespMsgType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case statusResp // = 0
  case errResp // = 1
  case infoResp // = 2
  case echoResp // = 3

  init() {
    self = .statusResp
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .statusResp
    case 1: self = .errResp
    case 2: self = .infoResp
    case 3: self = .echoResp
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .statusResp: return 0
    case .errResp: return 1
    case .infoResp: return 2
    case .echoResp: return 3
    }
  }

}

#if swift(>=4.2)

extension ApiProto_VpnRespMsgType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum ApiProto_ServiceTypes: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case taskIDOfEvent // = 16777215
  case ignoreTaskID // = 0

  init() {
    self = .taskIDOfEvent
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ignoreTaskID
    case 16777215: self = .taskIDOfEvent
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .ignoreTaskID: return 0
    case .taskIDOfEvent: return 16777215
    }
  }

}

#if swift(>=4.2)

extension ApiProto_ServiceTypes: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct ApiProto_VpnReqMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: ApiProto_VpnReqMsgType {
    get {return _type ?? .startVpn}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var data: ApiProto_VpnReqMsg.OneOf_Data? = nil

  var startVpnData: ApiProto_StartVpnData {
    get {
      if case .startVpnData(let v)? = data {return v}
      return ApiProto_StartVpnData()
    }
    set {data = .startVpnData(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case startVpnData(ApiProto_StartVpnData)

  #if !swift(>=4.1)
    static func ==(lhs: ApiProto_VpnReqMsg.OneOf_Data, rhs: ApiProto_VpnReqMsg.OneOf_Data) -> Bool {
      switch (lhs, rhs) {
      case (.startVpnData(let l), .startVpnData(let r)): return l == r
      }
    }
  #endif
  }

  init() {}

  fileprivate var _type: ApiProto_VpnReqMsgType? = nil
}

struct ApiProto_StartVpnData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blob: [UInt32] = []

  var transportPas: String {
    get {return _transportPas ?? String()}
    set {_transportPas = newValue}
  }
  /// Returns true if `transportPas` has been explicitly set.
  var hasTransportPas: Bool {return self._transportPas != nil}
  /// Clears the value of `transportPas`. Subsequent reads from it will return its default value.
  mutating func clearTransportPas() {self._transportPas = nil}

  var storagePass: String {
    get {return _storagePass ?? String()}
    set {_storagePass = newValue}
  }
  /// Returns true if `storagePass` has been explicitly set.
  var hasStoragePass: Bool {return self._storagePass != nil}
  /// Clears the value of `storagePass`. Subsequent reads from it will return its default value.
  mutating func clearStoragePass() {self._storagePass = nil}

  var capKeyBlob: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transportPas: String? = nil
  fileprivate var _storagePass: String? = nil
}

struct ApiProto_EventStateChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mOldState: ApiProto_IMainClientState {
    get {return _mOldState ?? .capkeyNeeded}
    set {_mOldState = newValue}
  }
  /// Returns true if `mOldState` has been explicitly set.
  var hasMOldState: Bool {return self._mOldState != nil}
  /// Clears the value of `mOldState`. Subsequent reads from it will return its default value.
  mutating func clearMOldState() {self._mOldState = nil}

  var mNewState: ApiProto_IMainClientState {
    get {return _mNewState ?? .capkeyNeeded}
    set {_mNewState = newValue}
  }
  /// Returns true if `mNewState` has been explicitly set.
  var hasMNewState: Bool {return self._mNewState != nil}
  /// Clears the value of `mNewState`. Subsequent reads from it will return its default value.
  mutating func clearMNewState() {self._mNewState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mOldState: ApiProto_IMainClientState? = nil
  fileprivate var _mNewState: ApiProto_IMainClientState? = nil
}

struct ApiProto_EventTunelSetup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vpnIp: UInt32 {
    get {return _vpnIp ?? 0}
    set {_vpnIp = newValue}
  }
  /// Returns true if `vpnIp` has been explicitly set.
  var hasVpnIp: Bool {return self._vpnIp != nil}
  /// Clears the value of `vpnIp`. Subsequent reads from it will return its default value.
  mutating func clearVpnIp() {self._vpnIp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _vpnIp: UInt32? = nil
}

struct ApiProto_EventTunelSetupProtect {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vpnGateway: UInt32 {
    get {return _vpnGateway ?? 0}
    set {_vpnGateway = newValue}
  }
  /// Returns true if `vpnGateway` has been explicitly set.
  var hasVpnGateway: Bool {return self._vpnGateway != nil}
  /// Clears the value of `vpnGateway`. Subsequent reads from it will return its default value.
  mutating func clearVpnGateway() {self._vpnGateway = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _vpnGateway: UInt32? = nil
}

struct ApiProto_EventSocket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var socketID: UInt64 {
    get {return _socketID ?? 0}
    set {_socketID = newValue}
  }
  /// Returns true if `socketID` has been explicitly set.
  var hasSocketID: Bool {return self._socketID != nil}
  /// Clears the value of `socketID`. Subsequent reads from it will return its default value.
  mutating func clearSocketID() {self._socketID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _socketID: UInt64? = nil
}

struct ApiProto_EventData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var evID: ApiProto_EventID {
    get {return _evID ?? .eventStateChange}
    set {_evID = newValue}
  }
  /// Returns true if `evID` has been explicitly set.
  var hasEvID: Bool {return self._evID != nil}
  /// Clears the value of `evID`. Subsequent reads from it will return its default value.
  mutating func clearEvID() {self._evID = nil}

  var data: ApiProto_EventData.OneOf_Data? = nil

  var stateChanged: ApiProto_EventStateChange {
    get {
      if case .stateChanged(let v)? = data {return v}
      return ApiProto_EventStateChange()
    }
    set {data = .stateChanged(newValue)}
  }

  var eventTunelSetup: ApiProto_EventTunelSetup {
    get {
      if case .eventTunelSetup(let v)? = data {return v}
      return ApiProto_EventTunelSetup()
    }
    set {data = .eventTunelSetup(newValue)}
  }

  var eventSocket: ApiProto_EventSocket {
    get {
      if case .eventSocket(let v)? = data {return v}
      return ApiProto_EventSocket()
    }
    set {data = .eventSocket(newValue)}
  }

  var eventTunelSetupProtect: ApiProto_EventTunelSetupProtect {
    get {
      if case .eventTunelSetupProtect(let v)? = data {return v}
      return ApiProto_EventTunelSetupProtect()
    }
    set {data = .eventTunelSetupProtect(newValue)}
  }

  var additionError: ApiProto_AdditionErrMsg {
    get {
      if case .additionError(let v)? = data {return v}
      return ApiProto_AdditionErrMsg()
    }
    set {data = .additionError(newValue)}
  }

  var sysAdditionEvents: ApiProto_SysAdditionalEvents {
    get {
      if case .sysAdditionEvents(let v)? = data {return v}
      return ApiProto_SysAdditionalEvents()
    }
    set {data = .sysAdditionEvents(newValue)}
  }

  var info: ApiProto_VpnConnectInfo {
    get {
      if case .info(let v)? = data {return v}
      return ApiProto_VpnConnectInfo()
    }
    set {data = .info(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case stateChanged(ApiProto_EventStateChange)
    case eventTunelSetup(ApiProto_EventTunelSetup)
    case eventSocket(ApiProto_EventSocket)
    case eventTunelSetupProtect(ApiProto_EventTunelSetupProtect)
    case additionError(ApiProto_AdditionErrMsg)
    case sysAdditionEvents(ApiProto_SysAdditionalEvents)
    case info(ApiProto_VpnConnectInfo)

  #if !swift(>=4.1)
    static func ==(lhs: ApiProto_EventData.OneOf_Data, rhs: ApiProto_EventData.OneOf_Data) -> Bool {
      switch (lhs, rhs) {
      case (.stateChanged(let l), .stateChanged(let r)): return l == r
      case (.eventTunelSetup(let l), .eventTunelSetup(let r)): return l == r
      case (.eventSocket(let l), .eventSocket(let r)): return l == r
      case (.eventTunelSetupProtect(let l), .eventTunelSetupProtect(let r)): return l == r
      case (.additionError(let l), .additionError(let r)): return l == r
      case (.sysAdditionEvents(let l), .sysAdditionEvents(let r)): return l == r
      case (.info(let l), .info(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _evID: ApiProto_EventID? = nil
}

struct ApiProto_VpnConnectInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ip: String {
    get {return _ip ?? String()}
    set {_ip = newValue}
  }
  /// Returns true if `ip` has been explicitly set.
  var hasIp: Bool {return self._ip != nil}
  /// Clears the value of `ip`. Subsequent reads from it will return its default value.
  mutating func clearIp() {self._ip = nil}

  var serverIp: String {
    get {return _serverIp ?? String()}
    set {_serverIp = newValue}
  }
  /// Returns true if `serverIp` has been explicitly set.
  var hasServerIp: Bool {return self._serverIp != nil}
  /// Clears the value of `serverIp`. Subsequent reads from it will return its default value.
  mutating func clearServerIp() {self._serverIp = nil}

  var bitrateTx: UInt32 {
    get {return _bitrateTx ?? 0}
    set {_bitrateTx = newValue}
  }
  /// Returns true if `bitrateTx` has been explicitly set.
  var hasBitrateTx: Bool {return self._bitrateTx != nil}
  /// Clears the value of `bitrateTx`. Subsequent reads from it will return its default value.
  mutating func clearBitrateTx() {self._bitrateTx = nil}

  var bitrateRx: UInt32 {
    get {return _bitrateRx ?? 0}
    set {_bitrateRx = newValue}
  }
  /// Returns true if `bitrateRx` has been explicitly set.
  var hasBitrateRx: Bool {return self._bitrateRx != nil}
  /// Clears the value of `bitrateRx`. Subsequent reads from it will return its default value.
  mutating func clearBitrateRx() {self._bitrateRx = nil}

  var traffic: UInt64 {
    get {return _traffic ?? 0}
    set {_traffic = newValue}
  }
  /// Returns true if `traffic` has been explicitly set.
  var hasTraffic: Bool {return self._traffic != nil}
  /// Clears the value of `traffic`. Subsequent reads from it will return its default value.
  mutating func clearTraffic() {self._traffic = nil}

  var memoryFootprint: UInt64 {
    get {return _memoryFootprint ?? 0}
    set {_memoryFootprint = newValue}
  }
  /// Returns true if `memoryFootprint` has been explicitly set.
  var hasMemoryFootprint: Bool {return self._memoryFootprint != nil}
  /// Clears the value of `memoryFootprint`. Subsequent reads from it will return its default value.
  mutating func clearMemoryFootprint() {self._memoryFootprint = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ip: String? = nil
  fileprivate var _serverIp: String? = nil
  fileprivate var _bitrateTx: UInt32? = nil
  fileprivate var _bitrateRx: UInt32? = nil
  fileprivate var _traffic: UInt64? = nil
  fileprivate var _memoryFootprint: UInt64? = nil
}

struct ApiProto_AdditionErrMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var err: ApiProto_VpnErrType {
    get {return _err ?? .none}
    set {_err = newValue}
  }
  /// Returns true if `err` has been explicitly set.
  var hasErr: Bool {return self._err != nil}
  /// Clears the value of `err`. Subsequent reads from it will return its default value.
  mutating func clearErr() {self._err = nil}

  var msg: String {
    get {return _msg ?? String()}
    set {_msg = newValue}
  }
  /// Returns true if `msg` has been explicitly set.
  var hasMsg: Bool {return self._msg != nil}
  /// Clears the value of `msg`. Subsequent reads from it will return its default value.
  mutating func clearMsg() {self._msg = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _err: ApiProto_VpnErrType? = nil
  fileprivate var _msg: String? = nil
}

struct ApiProto_SysAdditionalEvents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: ApiProto_SysAdditionalEventsType {
    get {return _type ?? .serviceReady}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: ApiProto_SysAdditionalEventsType? = nil
}

struct ApiProto_VpnConnectParam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var credFilePath: String {
    get {return _credFilePath ?? String()}
    set {_credFilePath = newValue}
  }
  /// Returns true if `credFilePath` has been explicitly set.
  var hasCredFilePath: Bool {return self._credFilePath != nil}
  /// Clears the value of `credFilePath`. Subsequent reads from it will return its default value.
  mutating func clearCredFilePath() {self._credFilePath = nil}

  var capFilePath: String {
    get {return _capFilePath ?? String()}
    set {_capFilePath = newValue}
  }
  /// Returns true if `capFilePath` has been explicitly set.
  var hasCapFilePath: Bool {return self._capFilePath != nil}
  /// Clears the value of `capFilePath`. Subsequent reads from it will return its default value.
  mutating func clearCapFilePath() {self._capFilePath = nil}

  var credFilePass: String {
    get {return _credFilePass ?? String()}
    set {_credFilePass = newValue}
  }
  /// Returns true if `credFilePass` has been explicitly set.
  var hasCredFilePass: Bool {return self._credFilePass != nil}
  /// Clears the value of `credFilePass`. Subsequent reads from it will return its default value.
  mutating func clearCredFilePass() {self._credFilePass = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _credFilePath: String? = nil
  fileprivate var _capFilePath: String? = nil
  fileprivate var _credFilePass: String? = nil
}

struct ApiProto_InitLibParam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cacheDirPath: String {
    get {return _cacheDirPath ?? String()}
    set {_cacheDirPath = newValue}
  }
  /// Returns true if `cacheDirPath` has been explicitly set.
  var hasCacheDirPath: Bool {return self._cacheDirPath != nil}
  /// Clears the value of `cacheDirPath`. Subsequent reads from it will return its default value.
  mutating func clearCacheDirPath() {self._cacheDirPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cacheDirPath: String? = nil
}

struct ApiProto_CallResStructProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var len: UInt32 {
    get {return _len ?? 0}
    set {_len = newValue}
  }
  /// Returns true if `len` has been explicitly set.
  var hasLen: Bool {return self._len != nil}
  /// Clears the value of `len`. Subsequent reads from it will return its default value.
  mutating func clearLen() {self._len = nil}

  var taskID: UInt32 {
    get {return _taskID ?? 0}
    set {_taskID = newValue}
  }
  /// Returns true if `taskID` has been explicitly set.
  var hasTaskID: Bool {return self._taskID != nil}
  /// Clears the value of `taskID`. Subsequent reads from it will return its default value.
  mutating func clearTaskID() {self._taskID = nil}

  var protoBuf: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _len: UInt32? = nil
  fileprivate var _taskID: UInt32? = nil
}

/// ios
struct ApiProto_EventsOfPacketTunnelProvider {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: [ApiProto_CallResStructProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "apiProto"

extension ApiProto_VpnReqMsgType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "StartVPN"),
    1: .same(proto: "StopVPN"),
    2: .same(proto: "UpdateStats"),
    3: .same(proto: "EchoReq"),
    4: .same(proto: "GetEvents"),
  ]
}

extension ApiProto_IMainClientState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CAPKeyNeeded"),
    1: .same(proto: "CredentialsNeeded"),
    2: .same(proto: "CredentialsPasswordNeeded"),
    3: .same(proto: "WrongCredentialsPassword"),
    4: .same(proto: "WaitingForNetwork"),
    5: .same(proto: "Connecting"),
    6: .same(proto: "Connected"),
    7: .same(proto: "Failed"),
    8: .same(proto: "Closing"),
    9: .same(proto: "Closed"),
  ]
}

extension ApiProto_EventID: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    -1: .same(proto: "UNKNOWN"),
    65537: .same(proto: "EVENT_SOCKET_OPENED"),
    65538: .same(proto: "EVENT_SOCKET_CLOSED"),
    131073: .same(proto: "EVENT_STATE_CHANGE"),
    196609: .same(proto: "EVENT_VPN_SETUP"),
    196610: .same(proto: "EVENT_VPN_CONNECTING"),
    196611: .same(proto: "EVENT_VPN_CONNECTED"),
    196612: .same(proto: "EVENT_VPN_DISCONNECTED"),
    196613: .same(proto: "EVENT_VPN_FAILED"),
    196614: .same(proto: "EVENT_VPN_PROTECT"),
    327680: .same(proto: "EVENT_ADDITION_ERROR"),
    393216: .same(proto: "EVENT_SYS_ADDITIONAL"),
    458752: .same(proto: "EVENT_INFO"),
  ]
}

extension ApiProto_VpnErrType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "AlreadyActive"),
    2: .same(proto: "CredFileNotFound"),
    3: .same(proto: "CredFileFileBad"),
    4: .same(proto: "CapFileNotFound"),
    5: .same(proto: "PassBad"),
    6: .same(proto: "NoRight"),
    7: .same(proto: "HelperConnectionLost"),
    8: .same(proto: "ServiceConLost"),
    9: .same(proto: "EmailisNotVerified"),
    500: .same(proto: "IntenalError_1"),
    501: .same(proto: "IntenalError_2"),
    502: .same(proto: "IntenalError_3"),
    503: .same(proto: "IntenalError_4"),
    504: .same(proto: "IntenalError_5"),
  ]
}

extension ApiProto_SysAdditionalEventsType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ServiceReady"),
  ]
}

extension ApiProto_VpnRespMsgType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "StatusResp"),
    1: .same(proto: "ErrResp"),
    2: .same(proto: "InfoResp"),
    3: .same(proto: "EchoResp"),
  ]
}

extension ApiProto_ServiceTypes: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ignoreTaskId"),
    16777215: .same(proto: "taskIdOfEvent"),
  ]
}

extension ApiProto_VpnReqMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VpnReqMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "startVpnData"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if case .startVpnData(let v)? = self.data, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._type)
      case 2:
        var v: ApiProto_StartVpnData?
        if let current = self.data {
          try decoder.handleConflictingOneOf()
          if case .startVpnData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.data = .startVpnData(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if case .startVpnData(let v)? = self.data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ApiProto_VpnReqMsg, rhs: ApiProto_VpnReqMsg) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApiProto_StartVpnData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartVpnData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blob"),
    2: .same(proto: "transportPas"),
    3: .same(proto: "storagePass"),
    4: .same(proto: "capKeyBlob"),
  ]

  public var isInitialized: Bool {
    if self._transportPas == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedUInt32Field(value: &self.blob)
      case 2: try decoder.decodeSingularStringField(value: &self._transportPas)
      case 3: try decoder.decodeSingularStringField(value: &self._storagePass)
      case 4: try decoder.decodeRepeatedUInt32Field(value: &self.capKeyBlob)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blob.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.blob, fieldNumber: 1)
    }
    if let v = self._transportPas {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._storagePass {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if !self.capKeyBlob.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.capKeyBlob, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ApiProto_StartVpnData, rhs: ApiProto_StartVpnData) -> Bool {
    if lhs.blob != rhs.blob {return false}
    if lhs._transportPas != rhs._transportPas {return false}
    if lhs._storagePass != rhs._storagePass {return false}
    if lhs.capKeyBlob != rhs.capKeyBlob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApiProto_EventStateChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventStateChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mOldState"),
    2: .same(proto: "mNewState"),
  ]

  public var isInitialized: Bool {
    if self._mOldState == nil {return false}
    if self._mNewState == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._mOldState)
      case 2: try decoder.decodeSingularEnumField(value: &self._mNewState)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mOldState {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._mNewState {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ApiProto_EventStateChange, rhs: ApiProto_EventStateChange) -> Bool {
    if lhs._mOldState != rhs._mOldState {return false}
    if lhs._mNewState != rhs._mNewState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApiProto_EventTunelSetup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventTunelSetup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "VpnIp"),
  ]

  public var isInitialized: Bool {
    if self._vpnIp == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._vpnIp)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._vpnIp {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ApiProto_EventTunelSetup, rhs: ApiProto_EventTunelSetup) -> Bool {
    if lhs._vpnIp != rhs._vpnIp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApiProto_EventTunelSetupProtect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventTunelSetupProtect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "VpnGateway"),
  ]

  public var isInitialized: Bool {
    if self._vpnGateway == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._vpnGateway)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._vpnGateway {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ApiProto_EventTunelSetupProtect, rhs: ApiProto_EventTunelSetupProtect) -> Bool {
    if lhs._vpnGateway != rhs._vpnGateway {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApiProto_EventSocket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSocket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SocketId"),
  ]

  public var isInitialized: Bool {
    if self._socketID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self._socketID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._socketID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ApiProto_EventSocket, rhs: ApiProto_EventSocket) -> Bool {
    if lhs._socketID != rhs._socketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApiProto_EventData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "evId"),
    2: .same(proto: "stateChanged"),
    3: .same(proto: "eventTunelSetup"),
    4: .same(proto: "eventSocket"),
    5: .same(proto: "eventTunelSetupProtect"),
    6: .same(proto: "additionError"),
    7: .same(proto: "sysAdditionEvents"),
    8: .same(proto: "info"),
  ]

  public var isInitialized: Bool {
    if self._evID == nil {return false}
    switch self.data {
    case .stateChanged(let v)?: if !v.isInitialized {return false}
    case .eventTunelSetup(let v)?: if !v.isInitialized {return false}
    case .eventSocket(let v)?: if !v.isInitialized {return false}
    case .eventTunelSetupProtect(let v)?: if !v.isInitialized {return false}
    case .additionError(let v)?: if !v.isInitialized {return false}
    case .sysAdditionEvents(let v)?: if !v.isInitialized {return false}
    case .info(let v)?: if !v.isInitialized {return false}
    default: break
    }
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._evID)
      case 2:
        var v: ApiProto_EventStateChange?
        if let current = self.data {
          try decoder.handleConflictingOneOf()
          if case .stateChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.data = .stateChanged(v)}
      case 3:
        var v: ApiProto_EventTunelSetup?
        if let current = self.data {
          try decoder.handleConflictingOneOf()
          if case .eventTunelSetup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.data = .eventTunelSetup(v)}
      case 4:
        var v: ApiProto_EventSocket?
        if let current = self.data {
          try decoder.handleConflictingOneOf()
          if case .eventSocket(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.data = .eventSocket(v)}
      case 5:
        var v: ApiProto_EventTunelSetupProtect?
        if let current = self.data {
          try decoder.handleConflictingOneOf()
          if case .eventTunelSetupProtect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.data = .eventTunelSetupProtect(v)}
      case 6:
        var v: ApiProto_AdditionErrMsg?
        if let current = self.data {
          try decoder.handleConflictingOneOf()
          if case .additionError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.data = .additionError(v)}
      case 7:
        var v: ApiProto_SysAdditionalEvents?
        if let current = self.data {
          try decoder.handleConflictingOneOf()
          if case .sysAdditionEvents(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.data = .sysAdditionEvents(v)}
      case 8:
        var v: ApiProto_VpnConnectInfo?
        if let current = self.data {
          try decoder.handleConflictingOneOf()
          if case .info(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.data = .info(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._evID {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    switch self.data {
    case .stateChanged(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .eventTunelSetup(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .eventSocket(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case .eventTunelSetupProtect(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case .additionError(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    case .sysAdditionEvents(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    case .info(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ApiProto_EventData, rhs: ApiProto_EventData) -> Bool {
    if lhs._evID != rhs._evID {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApiProto_VpnConnectInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VpnConnectInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
    2: .standard(proto: "server_ip"),
    3: .same(proto: "bitrateTx"),
    4: .same(proto: "bitrateRx"),
    5: .same(proto: "traffic"),
    6: .standard(proto: "memory_footprint"),
  ]

  public var isInitialized: Bool {
    if self._ip == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._ip)
      case 2: try decoder.decodeSingularStringField(value: &self._serverIp)
      case 3: try decoder.decodeSingularUInt32Field(value: &self._bitrateTx)
      case 4: try decoder.decodeSingularUInt32Field(value: &self._bitrateRx)
      case 5: try decoder.decodeSingularUInt64Field(value: &self._traffic)
      case 6: try decoder.decodeSingularUInt64Field(value: &self._memoryFootprint)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._ip {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._serverIp {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._bitrateTx {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._bitrateRx {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._traffic {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    }
    if let v = self._memoryFootprint {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ApiProto_VpnConnectInfo, rhs: ApiProto_VpnConnectInfo) -> Bool {
    if lhs._ip != rhs._ip {return false}
    if lhs._serverIp != rhs._serverIp {return false}
    if lhs._bitrateTx != rhs._bitrateTx {return false}
    if lhs._bitrateRx != rhs._bitrateRx {return false}
    if lhs._traffic != rhs._traffic {return false}
    if lhs._memoryFootprint != rhs._memoryFootprint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApiProto_AdditionErrMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AdditionErrMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "err"),
    2: .same(proto: "msg"),
  ]

  public var isInitialized: Bool {
    if self._err == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._err)
      case 2: try decoder.decodeSingularStringField(value: &self._msg)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._err {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._msg {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ApiProto_AdditionErrMsg, rhs: ApiProto_AdditionErrMsg) -> Bool {
    if lhs._err != rhs._err {return false}
    if lhs._msg != rhs._msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApiProto_SysAdditionalEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SysAdditionalEvents"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ApiProto_SysAdditionalEvents, rhs: ApiProto_SysAdditionalEvents) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApiProto_VpnConnectParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VpnConnectParam"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "credFilePath"),
    2: .same(proto: "capFilePath"),
    3: .same(proto: "credFilePass"),
  ]

  public var isInitialized: Bool {
    if self._credFilePath == nil {return false}
    if self._capFilePath == nil {return false}
    if self._credFilePass == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._credFilePath)
      case 2: try decoder.decodeSingularStringField(value: &self._capFilePath)
      case 3: try decoder.decodeSingularStringField(value: &self._credFilePass)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._credFilePath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._capFilePath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._credFilePass {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ApiProto_VpnConnectParam, rhs: ApiProto_VpnConnectParam) -> Bool {
    if lhs._credFilePath != rhs._credFilePath {return false}
    if lhs._capFilePath != rhs._capFilePath {return false}
    if lhs._credFilePass != rhs._credFilePass {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApiProto_InitLibParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitLibParam"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_dir_path"),
  ]

  public var isInitialized: Bool {
    if self._cacheDirPath == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._cacheDirPath)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cacheDirPath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ApiProto_InitLibParam, rhs: ApiProto_InitLibParam) -> Bool {
    if lhs._cacheDirPath != rhs._cacheDirPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApiProto_CallResStructProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallResStructProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "len"),
    2: .same(proto: "taskId"),
    3: .same(proto: "protoBuf"),
  ]

  public var isInitialized: Bool {
    if self._len == nil {return false}
    if self._taskID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._len)
      case 2: try decoder.decodeSingularUInt32Field(value: &self._taskID)
      case 3: try decoder.decodeRepeatedUInt32Field(value: &self.protoBuf)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._len {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._taskID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if !self.protoBuf.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.protoBuf, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ApiProto_CallResStructProto, rhs: ApiProto_CallResStructProto) -> Bool {
    if lhs._len != rhs._len {return false}
    if lhs._taskID != rhs._taskID {return false}
    if lhs.protoBuf != rhs.protoBuf {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApiProto_EventsOfPacketTunnelProvider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventsOfPacketTunnelProvider"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.data) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.data)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ApiProto_EventsOfPacketTunnelProvider, rhs: ApiProto_EventsOfPacketTunnelProvider) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
